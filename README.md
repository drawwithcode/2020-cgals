# Memorypedia
**Project idea** 

Memorypedia is a collaborative web experience about collective and personal memory, where with a simple and instant interaction, users can contribute to a continuously growing visual narration of words and images.
Revisiting a simple parlour game, it focuses on the psychology concept of involuntary memory, that is our capability of creating links between different worlds by referring to our own experience. The result is a chain of words and pictures, generated by all the contributions coming together. The digital platform allows participants to take part in the experience anywhere, anytime. 

![Tavola disegno 1@a](https://user-images.githubusercontent.com/40294384/105647496-7080bf80-5ea6-11eb-97a8-d1dbf483da11.png)

**Speculation**

The name of the project comes from the semiotic concept of “encyclopaedia” identified by Umberto Eco as the common array of all the knowledge and experiences shared by a group. 
This concept reflects on how communication has an evocative power that enables meanings that are not literal but come from the recipient or viewer’s personal experience. 

**Aim**

The huge amount of information provided by the Internet encourages forgetting rather than remembering. This web app is a celebration of both individual and collective memory but could also be seen as a provocative work with the aim of raising awareness of the problem of how technology affects our capability of remembering.

**Context of use**

The project is designed as a collaborative experience for sponsoring events related to memory and communication, such as the Italian Festival della Memoria.

**Device**

The app is designed as a desktop experience for a better usability, especially when handling images.

# Design Challenges
The app corporate image is simple but effective, with an essential palette: a light yellow for the background, a strong purple for the logotype and typographic details and plain balck and white. Typography is as minimal: two contrasting fonts, a serif one called Nanum Myeongjo, loaded from Google Fonts and a grotesk one, Helvetica. 
The design interaction is intuitive and elementary for a better experience and to maintain the essential “old school” style. The web app is structured into 8 pages:

* Homepage;
* About, an info page about the project;
* How to collaborate, that explains  the dynamics of the app;
* Introduction, where users can read a small introduction;
* Instructions, where users are told how to collaborate;
* Last contribution, here the user can see the last contribution and decide how to collaborate: with a word, a picture or a drawing;
* Add contribute, is divided into three parts based on the contribution that the user wants to add;
* Final page, here the user can see the entire chain of words, pictures and drawings composed by other users contributions.

![Tavola disegno 1@72x](https://user-images.githubusercontent.com/40294384/105647455-1da70800-5ea6-11eb-951e-611d38446004.png)

This web app connects users thanks to interaction: in fact each user has to see the contribution of the last person to add his own contribution and at last he can see all the contributions in a visual chain and try to discover the links between them.
We chose to show to the user only the last contribution to allow them to freely find links, without being influenced by other users’ contents.
The main design challenge was to personalise and place every interactive content in the web pages like buttons, textboxes, timers and so on.

# Code Challenges

The web app is made with p5.js, html, node.js, socket.io and Firebase as a realtime database to save data of the users’ contributions. 
The main challenges we had to face were:

* _Displaying images and text correctly in the final page._

The most challenging part was the final page, where contributions, both words and images, needed to be displayed in the right order. When iterating a for loop with all the elements of the data Object that needed to be retrieved, the function .createImg() was applied also to elements with the “word” variable, returning “undefined”. We solved this problem by creating an if statement:

	if (picture !== undefined && picture !== null) {
      let allImages = createImg(picture,
        () => {
   ...
    }
  );
}

To send data and then retrieve it and display elements from Firebase, we followed these tutorials by The Coding Train

https://www.youtube.com/watch?v=NcewaPfFR6Y&t=404s

https://www.youtube.com/watch?v=RUSvMxxm_Jo&feature=emb_logo


* _Saving drawings as images._ 

It was fundamental to save drawings as pictures before sending data to Firebase, in order to display them correctly in the final page. 
To solve this problem we used .toDataURL() function, that saves the canvas as a base64 string. 
	
    function saveDrawing() {
    var ref = database.ref("words");
      loadPixels();
    const image64 = canvas.toDataURL();
    console.log(image64);
    var data = {
      picture: image64
    }
          var result = ref.push(data, dataSent);
          console.log(result.key);

        function dataSent(status) {
          console.log(status);
        }

        window.open("finalpage.html", "_self")
    }

To learn how to handle images and base64 encoding we watched this tutorial by The Coding Train 

https://www.youtube.com/watch?v=9Rhsb3GU2Iw


* _Showing only the last contribution._ 

In order to select the last contribution to the chain, which is displayed on the page the user sees before choosing how to add their contribution, we created an array by retrieving data from Firebase and using the .slice() function we selected the last element of the array.
Then we used the function .find() to determine whether the last contribution was a word or an image: this allows the app to display the contribution correctly, with .createImg() for base64 strings and by creating a paragraph for words.

We consulted this page for coding the function that finds a specific value inside an array

https://developer.mozilla.org/it/docs/Web/JavaScript/Reference/Global_Objects/Array/find


* _Allowing only one person to add a contribution._ 

To prevent different users from “replying” to the same contribution, which could have happened if two connected simultaneously, we used socket.io to fill an array called “connectedUsers” every time a new connection takes place. If the array has more than 2 elements, the user that connected last is redirected to another page.  


* _Creating two canvases on the draw page._ 

In the draw page we needed two canvases: one that allows the user to draw and one for the background and other elements. The page worked better with only the drawing canvas created with p5.js and other elements handled in html (such as the background, the button and the timer).

# Inspirations

<img src="https://user-images.githubusercontent.com/40294384/105647463-28619d00-5ea6-11eb-8581-dbb5f3e81d9d.jpg" width="200" height="290" /> <img src="https://user-images.githubusercontent.com/40294384/105647464-2bf52400-5ea6-11eb-91ef-38e31906594f.jpg" width="200" height="290" /> <img src="https://user-images.githubusercontent.com/40294384/105647466-2e577e00-5ea6-11eb-96fd-8307cc819f10.jpg" width="200" height="290" />

# About
**Team members**

Alessia Arosio, Irene Casano, Soraya Astaghforellahi, Fatemeh Goodarzi

**Course**

Creative Coding 2020/2021

Politecnico di Milano - Dipartimento di Design

Faculty: Michele Mauri, Andrea Benedetti, Tommaso Elli



